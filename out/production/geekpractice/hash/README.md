# hash 
#### 散列表用的就是数组支持按照下表随机访问的时候，时间复杂度是O(1)的特性
### 常用的散列冲突解决方法： 1.开放寻址  2.链表法
#### 1.开放寻址法  ----如果出现散列冲突，我们就重新探测一个空闲位置，将其插入    查找过程与插入过程相似   删除时--将删除的元素标记为deleted。
### 散列的装载因子 = 填入表中的元素个数 / 散列表的长度
#### 2.链表法
#### 散列表的两个核心问题：1.散列函数设计 2.散列冲突解决
##### 我们还要把散列值转化为数组下标的 单纯散列值是没法直接拿来当下标的

#### 设计散列函数： 1.散列函数的设计不能太复杂  2.散列函数生成的值要尽可能随机并且均匀分布
#### 装载因子阈值的设置要权衡时间、空间复杂度。可以大于1.
#### 如何避免抵消地扩容  -- 将扩容操作穿插在操作的过程中，分批完成


#### LinkedHashMap 采用了链表法解决冲突，ThreadLocalMap 是通过线性探测的开放寻址法来解决冲突
### **散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的。**
### **也就是说，它无法按照某种顺序快速地遍历数据，如果希望按照顺序遍历散列表中的数据，那我们需要将散列表中的数据拷贝到数组中，然后排序，再遍历**
---
#### 将任意长度得二进制值串映射为固定长度的二进制值串，这个映射的规则就是**哈希算法**，而通过原始数据映射之后得到的二进制值串就是**哈希值**