# hash table
#### 散列表用的就是数组支持按照下表随机访问的时候，时间复杂度是O(1)的特性
### 常用的散列冲突解决方法： 1.开放寻址  2.链表法
#### 1.开放寻址法  ----如果出现散列冲突，我们就重新探测一个空闲位置，将其插入    查找过程与插入过程相似   删除时--将删除的元素标记为deleted。
### 散列的装载因子 = 填入表中的元素个数 / 散列表的长度
#### 2.链表法
#### 散列表的两个核心问题：1.散列函数设计 2.散列冲突解决
##### 我们还要把散列值转化为数组下标的 单纯散列值是没法直接拿来当下标的

#### 设计散列函数： 1.散列函数的设计不能太复杂  2.散列函数生成的值要尽可能随机并且均匀分布
#### 装载因子阈值的设置要权衡时间、空间复杂度。可以大于1.
#### 如何避免抵消地扩容  -- 将扩容操作穿插在操作的过程中，分批完成


#### LinkedHashMap 采用了链表法解决冲突，ThreadLocalMap 是通过线性探测的开放寻址法来解决冲突
